# 图（2）
- 图（2）讨论一些图上的问题以及对应算法的思想
- 算法的代码实现可以自行在网上搜索

---
---

## 1. 最短路径问题
- 最短路径问题定义在边有权重的有向图上，问题寻找从“源点”到“汇点”的最小权路径。

- 该问题有两大类算法：
    - 第一类算法可以给出“单源全汇”最短路径问题的解（即给出从固定源点到图上任意点的最短路径），
    - 第二类算法可以给出“全源全汇”最短路径问题的解（即给出从图上任意点到任意点的最短路径）。
    - “全源单汇”“单源单汇”问题同样使用第一类算法给出路径。
---
### 1.1 单源全汇问题
#### 1.1.1 算法简介
  - 对于“单源全汇”问题，我们设图有v个点和e条边，有以下两种算法：
    - Dijkstra算法（适用于边权重非负的图）——O(V^2)复杂度
    - Bellman-Ford算法（适用于有负权重边的图）——O(VE)复杂度
  - 在大多数情况下（除了很稀疏的图），Dijkstra算法的复杂度都优于Bellman-Ford算法
  - 在解决问题中考虑能否引入“边权非负”的先验知识是很有必要的。

#### 1.1.2 算法优化
- Dijkstra算法有堆优化版本(2022年数算第6次OJ所用的算法)，复杂度O(ElogV)
- Bellman-Ford算法有队列优化版本(spfa算法)，平均复杂度O(kE)，k是一个较小的常数，但在最坏情况下退化到O(VE)

---
#### 1.1.3 朴素Dijkstra算法
- 定义集合:
  - V=node[v]//存储node和现有最短路径node[i].min
  - E=edge[i][j]//存储edge和边权重weight
  - S={0,......}（已找到最短距离的node）
- 初始化：
  - S={0}
  - node[0]=0
  - node[i].min=无穷
- 递归：每次向S中添加一个元素，直至S=V
- 递归方法：
  - 查找S中每个node[i]伸出的edge[i][j]，
  - 更新node[j].min=min{node[j].min ,node[i].min+edge[i][j].weight}
  - 最后将node[j].min最小的j加入S
---
#### 1.1.4 堆优化的Dijkstra算法
- 考虑朴素Dijkstra算法，每一条edge[i][j]都被查找更新了多次，但其中很多次都是在node[i].min没有发生变化的情况下再一次更新，因此考虑进行堆优化避免这样的重复计算。
- 堆优化：
  - 每次递归只查找上次递归新增的node[i]
  - 将min=node[i].min+edge[i][j].weight放进队列{edge[i][j],min}
  - Ps：队列按照min从小到大排列
  - 最后将队列顶的edge[i][j]（要求满足j ∉ S，否则将其移出队列并查看下一个）加入S，记录node[j].min=min
---
#### 1.1.5 Bellman-Ford算法
- BF算法基于松弛的思想。
- 所谓一次松弛操作，即遍历图的每一条edge[i][j]执行如下操作：
  - node[i].min=min{node[i].min,node[j].min+edge[j][i]}
  - 用i点的当前最短路径和edge[i][j]的权重试图更新j点的最短路径
- 工作原理
  - 数学上可以证明，进行V-1次松弛，在最短路径问题上即相当于遍历了所有边数<=V-1的路径。
  - 数学上还可以证明，任意源点汇点的最短路径其边数一定<=V-1
  - 因此在进行了与朴素Dijkstra算法相同的集合定义与初始化后，执行V-1次松弛即可找到源点到任意汇点的最短路径。
- 需要注意的是，Bellman-Ford算法可以处理负权问题，但最短路径问题不允许图中有负环
  - 负环：一条环，总权重为负数
  - 因为自然地，我们可以在负环上多绕几圈以降低路径的权重，这会导致部分乃至全部点不存在最短路径
  - 值得一提的是Bellman-Ford算法可以用于判断图是否具有负环，负环存在的判定条件：第V次松弛仍有node[i].min变小（被更新了）
--- 
#### 1.1.6 spfa算法（队列优化的Bellman-Ford算法）
- 数据准备
  - 一个队列q（先进先出）保存待优化的结点node[i]
  - 一个标记数组vis[V]记录某点是否在队列中
  - 一个数组dist[V]，存储到某点的最短距离,初始化为正无穷
- 循环方法
  - 每次循环取出队首node[i]
  - 用node[i].min对所有edge[i][j]进行松弛操作
  - 如果node[j].min有所调整，且node[j]不在队列中，则node[j]入队
  - 循环直至队列空为止
- 负环存在判定：存在node[i]进入队列的次数超过V

---

### 1.2 全源全汇问题
#### 1.2.1 Floyd算法
- Floyd算法思想较为朴素
- 数据准备：初始边值矩阵<sub>0</sub>[i][j],存储edge的权重
- V次迭代，每次迭代更新：
  - E<sub>k+1</sub>[i][j]=min{E<sub>k</sub>[i][j],E<sub>k</sub>[i][p]+E<sub>k</sub>[p][i]}
  - p=0,1,......,V-1
- 即可得到源最短路径矩阵E<sub>v</sub>[i][j]
- 算法的复杂度为O(n^3)
- 算法允许边权为负数，但不允许负权回路

---
---

## 2. 最大流问题
### 2.1 问题的现实模型
- 一个城市，有路网，每条路每个方向都有通行的流量上限。
- 希望知道从A地到B地最大能以多大流量通行
    >对于m源n汇求总流量最大值：可以补充m个s’，n个t’分别与单个源s和单个汇t有无穷大流量c，然后求s和t之间的最大流
---
### 2.2 数学建模
- 有向完全图G
    >不妨将图用0权边补充为完全图
- 边权c为边的最大流量
- 求从源s到汇t的最大流量|f|
- 边性质:有向/无自环/权值c非负/c[i][j]&c[j][i]不同时出现
    >现实问题中的双向道路双向边可以将其中一条边中间添加一虚拟节点v’以符合要求
- 定义流：f[i][i]满足0<=f[i][j]<=edge[i][j]
    >f[i][j]是i到j的边流量
- 无源性(保守性)(流入=流出)：$\sum_{v∈V}f[u][v]=\sum_{v∈V}f[v][u]$
- 定义流量：$|f|=\sum_{v∈V}f[s][v]=\sum_{v∈V}f[v][t]$
---
### 2.3 Ford-Fulkerson方法
>由于Ford-Fulkerson不限制找到简单路的方法，即可以选用各种找简单路的算法来执行Ford-Fulkerson中，因此Ford-Fulkerson称为方法而非算法。
- 找简单路的算法多种多样，可以参考离散数学课程内容，在此不做讨论
---
### 2.4方法思路：
- 由流f和容量c得到残留网络G<sub>f</sub>，定义残留容量c<sub>f</sub>[i][j]
- c<sub>f</sub>[i][j]
  - =c[i][j]-f[i][j]//对edge[i][j]存在//代表剩余流量可以使用
  - =f[j][i]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                    //对edge[j][i]存在//代表已有流量可以减小
  - =0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                    //其他情况
- 残留容量物理意义：可用的剩余流量
- 残留网络中找到流f’,则f↑f’仍然满足图G的边上的容量约束
- 且|f↑f’|=|f|+|f’|会使流量变大
  - 定义f↑f’=f[i][j]+f’[i][j]-f’[j][i]//对存在的边edge[i][j]
  - &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&//对不存在的边（边权为0）
- 因此求图G中最大流的问题就转换成了不断在图Gf中找到f’(增广流)的问题，直到找不到
    >- 最大流最小割定理：以下三者等价
    >   - -|f|最大
    >   - Gf不存在增广路
    >   - |f|=c(S,T),其中(S,T)是G的“容量最小的割”
    >- 补充定义“割”和“割的容量”：
    >   - 对于图G(V,E)及其上容量c[i][j]
    >   - 定义割(S,T)满足：
    >       - S$\cup$T=V
    >       - S$\cap$T=∅
    >   - 定义割(S,T)的容量:
    >       - c(S,T)=$\sum_{i∈S}\sum_{j∈T}c[i][j]$
- 找f’：只需能找到图Gf的增广路p(即从源到汇的简单路)
---
---
## 3. 匹配问题
- 匹配问题的种类极多，应用范围很广，算法也很多且都很复杂，本文仅做简单介绍。
---
### 问题简介
- 匹配问题的本质通俗来讲就是多个打工人(集合L)&多个待执行任务(集合R)之间的问题。其中每个打工人可以引入各种千奇百怪的信息（干各项任务的效率、单次工作的最大时长、同时可以干几个任务.......）每个待执行任务也同样可以有各种信息，而在这些信息的约束下，我们寻求最佳的“给各个任务安排打工人完成”的方法。
---
### 匹配问题的类型
  - 多个打工人(集合L)&多个待执行任务(集合R)
  - 最大匹配：最多打工人有活干
  - 最小权匹配：打工人有完成任务时长，串行总时间花费最小
  - 瓶颈匹配：任务可并行，需要最小化最长单项任务耗时
  - 稳定匹配：解决稳定婚姻问题
  - 版匹配：解决多任务分配
  - ...无穷尽也
---
### 最简单的匹配问题的数学模型
> - 只引入信息：打工人A能/不能干任务B，一人干一个任务
> - 也是离散课堂上所讲的模型
- 二分图G(V,E)满足V=L$\cup$R，L$\cap$R=∅，E为L&R之间的边
- 设|L|=m，|R|=n，记二分图为G(L$\cup$R，E)
- 记完全二分图为K<sub>mn</sub>，不妨设二分图中无孤立点
- 一个匹配M（一个边集）：M⊆E，M无公共端点
- 若边edge[i][j]∈M，则称i和j被匹配M饱和
- 定义最大匹配：边数最多的M
- 定义完美匹配：所有顶点饱和的M
---
#### 在这个数学模型下，我们有一个匹配问题：找最大匹配（找到最多打工人有任务干的分锅方法）
#### 这个问题的解决方法就是离散课上大名鼎鼎的“匈牙利算法”
---
---
## 4. tips
- 尽管本文内容已经很多了（实测思路就要讲一节课时间），但对于图的算法只是相当基础的一些知识。
- 本文还有很多算法没有被提及
  - 比如如何优化全源全汇最短路径用的Floyd算法
  - 最大流问题能否拓展设定多源多汇并给予权重（收益系数）后计算收益最高的流
  - 如何解决各种各样的匹配问题......
- 感兴趣的同学可以自行查找资料继续学习（笔者学不动了）